
## 目的

系统的学习数据库索引相关知识，了解索引的原理，了解优化器的行为，了解查询的影响因素，量化索引的评估指标  

通过学习做到：  
前瞻性的索引设计，尽量在数据库设计阶段，选择最优的索引设计  
被动式的索引设计，针对现有数据库索引，找到最佳优化方案  
索引重组，针对现有最佳设计的索引，监控优化

## 内容

### 走出误区

* 网络信息的只言片语
* 案例的简单，不可实用
* 人云亦云的传播

随着硬件的升级，计算资源的丰富，有些问题已经不再是主要问题

* 索引层级（内存够大）
* 索引数量（磁盘空间够大，业务场景）
* 索引不稳定的列（不稳定列的层级相关）

### 系统资源

> 都说数据库是 IO 密集型，为什么？

* 磁盘
	* 磁盘的硬件结构
		* 磁片 磁道 扇区 柱面
	* 怎么读
		* 随机读 vs 顺序读
	* 怎么写
		* 随机写 vs 顺序写
	* 性能
	* 机械硬盘 vs 固体硬盘

> 读取和写入数据，cpu 内存 硬盘 的数据流动过程？

* 层次存储结构
	* cpu 缓存
	* 内存缓存
	* 硬盘缓存
	* 硬盘读写
	* 网络续写

* 读取磁盘需要的成本
	* 数据库最小读取数据块
		* 一个存储页
	* IO 排队时间
		* 3 ms，取决于繁忙度
	* 服务时间（寻道，旋转）
		* 4 ms
	* 传输
		* 1 ms
	* 一次随机读的理想时间
		* 10 ms

### 数据库数据的存储

> 数据库系统为什么要这样存储数据？

* 数据表数据的存储方式
	* 数据分页，页大小 8KB ...
* 索引的存储方式

> 排序的重要性

* 表聚簇
* 索引列排队

> 磁盘数据读取的优化
	* 提前读
	* 跳跃读
	* 延迟写
	* 同步 vs 异步

### SQL 的处理过程

> 一条 sql 怎么样被优化器处理和执行的？

* 谓词
	* where 过滤条件
	* 过滤因子
	* 可优化 vs 不可优化
	* 对索引设计的影响
	
* 访问路径
	* 索引选择
		* 读取到的索引片（越窄越好）
		* 匹配
		* 过滤
	* 表数据读取
		* 过滤

* 排序
	* 对索引设计的影响
	* 对查询性能的影响

* 物化结果
	* select 列数据
	* 对所有设计的影响
	* 对执行速度的影响

### 理想索引
	
> 简单理解，理想的索引是 index only scan，覆盖 select where order

* 三星索引，理想索引
	* 所有等值谓词，索引全部覆盖
		* 索引列的顺序
	* 排序覆盖
		* 索引列的顺序
	* 无需回表
		* 宽索引

> 鱼与熊掌不可兼得，候选法

* 候选 A，谓词满足优先
	* 等值谓词覆盖（前导列）
	* 范围谓词覆盖
	* 选择性兼容排序
	* 无需回表

* 候选 B，排序满足优先
	* 等值谓词覆盖
	* 排序覆盖，排序优先，调整等值谓词顺序
		* 无需回表

> 大部分场景选 A，但只需前 N 条的排序，B 胜出
> 所有面临的尴尬
	* 完全多余的索引
	* 近乎多余的索引
	* 可能多余的索引
	* 新增所以的代价

### 前瞻性的索引设计

> 对于没有实际数据情况下，怎么根据业务可能演化，选择最近的索引？

* 基本问题法（BQ）
	* 一个查询是否有现有的所以覆盖
	* 一个查询再无现有索引覆盖下，怎么实现覆盖？
		* 宽索引
		* 新建索引
		* 候选索引选择
		
* 快速上限估算法（QUBE）
	* LRT
		* 本地相应时间，在数据库服务器上执行一条 select 的时间
	* TR
		* 随机访问的数量
		* 假设一次随机读取 10 ms（排队，寻道/转圈，传输）
	* TS
		* 顺序访问的数量
		* 顺序读取 0.01 ms（CPU 时间与 IO 时间重叠）
		* 数据库在判断是否接受一行时所做的必要处理时间，不管在索引中还是表中，所有的行必须进行这一步检测
	* F
		* 取数据数量
		* 取一条数据耗时 0.1 ms（页大小 4 KB，磁盘速度 40 MB/s, 读取一页 0.4 / 40 = 0.1 ms）
	* 公式，假设都是理想的顺序读（表数据，索引数据）
		* LRT = TR * 10 ms + TS * 0.01 ms + F * 0.1 ms

* 索引片，窄 vs 厚
* 过滤因子，前导列
* 半宽索引 vs 宽索引
* 困难谓词
	* LIKE
	* IN
	* OR
	* 布尔操作（范围）
	* **现代数据库特殊性，bitmap index scan**

* 多表连接
	* 单表索引覆盖谓词
	* 星型连接，优化器不按套路出牌，访问路径选择的不确定性
	* 反范式设计，数据冗余
	* 连接方式
		* nested loop
		* hash
		* sorted merge
	* 维度表与事实表
		* 汇总表
		* 统计表

### 被动式索引设计

> 经常说的数据库性能调优，一般指 SQL 优化，应该一上来就是改 SQL 吗?

* explain (analyze,verbose,timing,costs,buffers)
* 性能监视器
	* LRT 监控
	* 尖刺报告
		* 标识
			* 程序名
			* 主要模块（对 LRT 贡献最大）的名称
			* 主要模块对 LRT 的贡献（%）
			* 日期
			* 结束时间（hh.mm.ss）
		* 事务概述
			* 本地相应时间（s）LRT
			* SQL 调用的总时间（s）SQL
			* SQL 调用的 CPU 时间（s）CPU 时间
			* 同步读时间（s）同步读
			* 等待预读取的时间（s）预读等待
			* 锁等待时间（s）锁等待
			* 其他等待时间（s）其他等待
			* 平均同步读时间（ms）
			* 同步读次数（表页）
			* 异步读次数（索引页）
			* SQL 调用次数
			* 访问的表页数量
			* 访问的表索引页数量
			* 顺序预读取请求数
			* 提交次数
			* 快速诊断（有以上数字得出）
	* 问题受害者与问题制造者
	* 分析有优化空间的问题制造者
	* 调优空间

### 多索引访问

> 通过扫描多个索引，取索引并集和索引交集

* 索引 AND
* 索引 OR
* 位图索引
* 索引连接


### 其他

* 索引重组
* 其他评估
* 单表数据量大，优化无空间
* 连接数据量大，优化无空间

## 继续

* BTREE 索引的本质
* 尖刺报告，查询数据的监控
